#+TITLE: Trevoke's emacs config
#+OPTIONS: toc:4 h:4

* About
<<babel-init>>
Welcome to my emacs configuration.
I tinker with this file a lot, so I need a quick way to get to it.
I set a [[*Bookmarks][bookmark]] with =C-x r m= and I can get back here with =C-x r b=
** TODO Minor modes?
I could create here some empty minor modes based on how I think about a buffer, hook those to whatever major modes I care about, and then just hook to the minor mode everywhere else in my configuration.
* External links
This is here so it's easier for me to remember what Ι need to set up on a new machine. You'd think a script would be better. Yep. Script is next.
#+begin_src emacs-lisp
(setq stag-easy-hugo-basedir "~/src/projects/trevoke.github.io-source")
(setq stag-easy-hugo-root "~/src/projects/trevoke.github.io")
(setq stag-org-reveal-root "file:///~/src/vendor/reveal.js-3.8.0")

(setq stag-org-directory "~/my-life/orgnotes/")

(setq stag-org-gtd-directory "~/my-life/orgnotes/gtd")
(setq stag-org-roam-directory "~/my-life/orgnotes/roam")
(setq stag-org-roam-db-location "~/.emacs.d/local-files/org-roam.db")
(setq stag-bbdb-file "~/my-life/orgnotes/bbdb/big-brother-database")
(setq stag-org-brain-directory "~/my-life/from-dropbox/orgnotes/brain")
#+end_src
* Personal information
Stored in ~~/.emacs.d/.emacs.secrets~.
* General emacs config
** Low-level behavior
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 100 1024 1024))
#+end_src
** Customizations from customization system
Keeping these separate makes life easier: they get modified when I load a theme and such, and I don't need that kind of hassle when maintaining my actual configuration, you know?
In addition, I do keep some somewhat computer-specific stuff in there, like the font, and it's just easier to have this separated there.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file t) ;; t means no error if file does not exist
#+END_SRC
** Additional paths
*** Themes
#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
;; (load-theme 'mejelly t)
#+END_SRC
*** Packages (without package management)
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages")
#+END_SRC
*** Secrets
API keys, passwords, etc are kept in here. This file is .gitignored.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/.emacs.secrets" t)
#+END_SRC
*** executable versioning (mostly programming languages)
#+BEGIN_SRC elisp
  (setenv "PATH" (concat (getenv "PATH") ":~/.asdf/shims"))
  (setq exec-path (append exec-path '("~/.asdf/shims")))
#+END_SRC
** Package management
*** The package manager: =use-package=
I use [[https://github.com/jwiegley/use-package][=use-package=]], because:
1. it is integrated within emacs.
2. it allows me to set up emacs on any OS I desire more easily than other options I've encountered so far
3. it allows me to easily share / steal configuration snippets
*** A new package browser
#+BEGIN_SRC emacs-lisp
(use-package paradox)
#+END_SRC
** Yes/No => y/n
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Visual choices
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)
(setq inhibit-splash-screen t)
(show-paren-mode t)
(setq show-paren-delay 0)
(global-hl-line-mode t)
(setq column-number-mode t)
(setq ring-bell-function 'ignore)
(setq visible-bell t)
(setq system-uses-terminfo nil)
#+END_SRC

This shows the file path in the GUI header
#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format
                '((:eval (if (buffer-file-name)
                             (abbreviate-file-name (buffer-file-name))
                           "%f"))))
#+END_SRC
** Backups
Centralize emacs backups. This directory is gitignored.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/local-files/backups")))
#+END_SRC
And I'm not super-worried about old backups and other such things, so I'll just tell emacs to stop worrying about it.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/local-files/auto-save-list/" t)))
#+END_SRC
** Recent files
#+begin_src emacs-lisp
(use-package recentf
  :ensure nil
  :init
  (setq recentf-save-file "~/.emacs.d/local-files/recentf"))
#+end_src
** Bookmarks
#+begin_src emacs-lisp
(use-package bookmark
  :ensure nil
  :init
  (setq bookmark-default-file "~/.emacs.d/local-files/bookmarks"))
#+end_src
** History
Stolen from https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/local-files/savehist")
(savehist-mode 1)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
** TODO Window config (Put OSX stuff somewhere else)
I don't really care about any of the extra details - emacs helps me out enough in other ways.
#+BEGIN_SRC emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC
Although of course if you're on OSX, at least the menu bar can be enabled since the mighty OSX top bar won't ever disappear.
And I've also added other OSX-specific stuff here... For now.
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
    (setq mac-command-modifier 'super)
    (setq mac-option-modifier 'meta)
    (use-package exec-path-from-shell
      :config
      (exec-path-from-shell-initialize))
    (setq ns-use-srgb-colorspace t)
    (menu-bar-mode t))
#+END_SRC
** UTF-8
#+BEGIN_SRC emacs-lisp
;; Activate UTF-8 mode:
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; 2013-12-10 IRC #Emacs
(set-clipboard-coding-system 'utf-8)

;; http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/
;; in addition to the lines above:

(set-default-coding-systems 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC
** Buffer management
I like unique buffer names. Enter uniquify.
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq
  uniquify-buffer-name-style 'post-forward
  uniquify-separator ":")
#+END_SRC
Also, ibuffer is nicer than plain-old buffer window
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer-other-window)
(setq ibuffer-default-sorting-mode 'major-mode)
#+END_SRC
** Scrolling
#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq scroll-conservatively 10000)
(setq auto-window-vscroll nil)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
#+END_SRC
** Frame management
*** Transparency
#+BEGIN_SRC emacs-lisp
(use-package seethru :pin "melpa")
#+END_SRC
** Window management
*** Window layout manager (eyebrowse)
Prefix key is =C-c C-w=
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :init (setq eyebrowse-new-workspace t)
  :config (eyebrowse-mode))
#+END_SRC
*** Winner-mode (undo/redo window changes)
Remember: =C-c <left>= and =C-c <right>=
#+BEGIN_SRC emacs-lisp
(winner-mode)
#+END_SRC
*** Windmove (move across windows with shift+arrow)
#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)

#+END_SRC
*** Move to new window when splitting
Taken from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury
#+BEGIN_SRC emacs-lisp
(defun stag-vsplit-last-buffer (prefix)
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (unless prefix
          (switch-to-next-buffer)))

(defun stag-hsplit-last-buffer (prefix)
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (unless prefix
    (switch-to-next-buffer)))

(global-set-key (kbd "C-x 2") 'stag-vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'stag-hsplit-last-buffer)
#+END_SRC
** Interacting with emacs
*** Fonts and stuff
I found this function online somewhere, before I thought tracking code origin for this config file might matter.
All it does is tell you what face is at point.
#+BEGIN_SRC emacs-lisp
(defun stag-what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC
*** evil-mode
Because sometimes, vim.
#+BEGIN_SRC emacs-lisp
(use-package evil)
#+END_SRC
*** Disable C-z to minimize
Suspend emacs？ I'll use C-x C-z.
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+END_SRC
** text scaling
This handy little package increases the size of the font in the whole frame.
#+BEGIN_SRC emacs-lisp
(use-package default-text-scale
  :bind (("C-x C-=" . default-text-scale-increase)
         ("C-x C--" . default-text-scale-decrease)))
#+END_SRC
** Color themes
#+BEGIN_SRC emacs-lisp
(use-package modus-operandi-theme :defer t)
(use-package modus-vivendi-theme :defer t)
#+END_SRC

** Define text interactions
*** Use visual-line-mode
#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC
*** Redefine kill-region and backward-kill-word
I used Bash for a long time. This allows me to keep using Ctrl-w to delete a word backward.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-x C-k") 'kill-region)
#+END_SRC
*** Move down real line by real line
#+BEGIN_SRC emacs-lisp
(setq line-move-visual nil)
#+END_SRC
*** Sentences end with a single space
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Inserting new lines before/after current one
#+BEGIN_SRC emacs-lisp
(defun stag-insert-line-below ()
  "Insert and auto-indent line below cursor, like in vim."
  (interactive)
  (move-end-of-line 1)
  (open-line 1)
  (next-line)
  (indent-for-tab-command))

(defun stag-insert-line-above ()
  "Insert and auto-indent line above cursor, like in vim."
  (interactive)
  (previous-line)
  (move-end-of-line 1)
  (stag-insert-line-below))

(global-set-key (kbd "C-o") 'stag-insert-line-below)
(global-set-key (kbd "C-M-o") 'stag-insert-line-above)
#+END_SRC

*** Navigating text
avy is kinda badass.
#+BEGIN_SRC emacs-lisp
(use-package avy
    :bind (("C-c j" . avy-goto-char-2)
           ("C-x j" . avy-po-mark)))
#+END_SRC
* Extending emacs with engines

** minibuffer
#+begin_src emacs-lisp
    ;;   (setq completion-flex-nospace nil)
  ;;   (setq completion-pcm-complete-word-inserts-delimiters t)
  ;;   (setq completion-pcm-word-delimiters "-_./:| ")
  ;;   (setq completion-show-help nil)
    ;;   (setq completions-format 'vertical)   ; *Completions* buffer
  ;;   (setq enable-recursive-minibuffers t)
  ;;   (setq read-answer-short t)

(use-package minibuffer
  :ensure nil
  :demand
  :custom
  (completion-styles '(partial-completion initials))
  (completion-category-defaults nil)
  (completion-cycle-threshold t)
  (completion-ignore-case t)
  (completion-prompt-speed-threshold 80)
  (read-buffer-completion-ignore-case t)
  (read-file-name-completion-ignore-case t)
;;  (completions-format 'vertical)
  (resize-mini-windows t)
  :config
  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)
  :bind (("C-x C-m" . execute-extended-command)))


#+end_src
** Command completion
#+BEGIN_SRC emacs-lisp
  (use-package icomplete
    :ensure nil
    :demand
    :config
    (setq icomplete-delay-completions-threshold 100)
    (setq icomplete-max-delay-chars 2)
    (setq icomplete-compute-delay 0.2)
    (setq icomplete-show-matches-on-no-input t)
    (setq icomplete-hide-common-prefix nil)
    (setq icomplete-prospects-height 1)
    (setq icomplete-separator (propertize " · " 'face 'shadow))
    ;; (setq icomplete-separator " │ ")
    ;; (setq icomplete-separator " ┆ ")
    ;; (setq icomplete-separator " ¦ ")
    ;; (setq icomplete-separator " ┆ ")
    (setq icomplete-with-completion-tables t)
    (setq icomplete-tidy-shadowed-file-names t)
    (icomplete-mode 1))

  (use-package icomplete-vertical
    :after (minibuffer icomplete)
    :config
    (setq icomplete-vertical-prospects-height 10)
    (setq icomplete-prospects-height 10)
    (icomplete-vertical-mode 1))
#+END_SRC
** Text Completion
*** company-mode
#+BEGIN_SRC emacs-lisp
(use-package company)
#+END_SRC
*** Snippets
Snippets; when you've tried 'em, it's hard to do without 'em. I mean, keystrokes, who needs 'em, right?
#+BEGIN_SRC emacs-lisp
(use-package yasnippet :diminish yas-minor-mode)
#+END_SRC
** In-buffer navigation
#+begin_src emacs-lisp
(use-package imenu
  :ensure nil
  :demand
  :config
  (setq imenu-use-markers t)
  (setq imenu-auto-rescan t)
  (setq imenu-auto-rescan-maxout 600000)
  (setq imenu-max-item-length 100)
  (setq imenu-use-popup-menu nil)
  (setq imenu-eager-completion-buffer t)
  (setq imenu-space-replacement " ")
  (setq imenu-level-separator "/"))

(use-package imenu-list
  :after imenu)
#+end_src
** Project navigation
Projectile is pretty sweet.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :after icomplete
  :diminish projectile-mode
  :init
  (setq projectile-known-projects-file "~/.emacs.d/local-files/projectile-bookmarks.eld")
  (setq projectile-cache-file "~/.emacs.d/local-files/projectile.cache")
  :config
  (projectile-global-mode)
  (setq projectile-completion-system 'default)
  :bind (("C-c p" . projectile-command-map)))
#+END_SRC

** Searching
*** Anzu (about search results)                            :external:minor:
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :config (global-anzu-mode t)
    :bind (("M-%" . anzu-query-replace)
           ("C-M-%" . anzu-query-replace-regexp)))
#+END_SRC
*** Silver searcher + Wgrep-ag
Sometimes after you've found a bunch of things, you want to edit.. Kind of a find-and-replace sort of deal, maybe?

I forget the basic keybindings all the time: After a search using =ag=, use C-c C-p to start editing the results buffer, and use C-c C-c to save the changes and C-c C-k to cancel.
#+BEGIN_SRC emacs-lisp
(use-package ag
  :config
  (setq ag-reuse-buffers 't))

(use-package wgrep-ag
  :after ag
    :init  (add-hook 'ag-mode-hook 'wgrep-ag-setup)
    :config (autoload 'wgrep-ag-setup "wgrep-ag"))
#+END_SRC
* File system browsing
** Dired
dired-jump is awesome (C-x C-j in any buffer)
#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Changed my mind. I prefer seeing just the files:
 (add-hook 'dired-mode-hook 'dired-hide-details-mode)

;; Auto-refresh silently
 (setq global-auto-revert-non-file-buffers t)
 (setq auto-revert-verbose nil)
#+END_SRC

This will make org-mode behave kinda like a two-pane file manager: with two direds open, you can copy/rename and the default target will be the other pane.
Using split-window-vertically from the first dired might be required to make this work.
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

OSX.. Windows.. *sigh*.
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program nil)
(require 'ls-lisp)
#+END_SRC

It's also nice to have dired with M-< and M-> take you to first and last file
#+BEGIN_SRC emacs-lisp
(require 'dired)
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (next-line 2))

(define-key dired-mode-map
  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (next-line -1))

(define-key dired-mode-map
  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
#+END_SRC
** Tramp
hadoop with tramp, please.
=C-x C-f /hdfs:username@hadoop-server:/path/to/dir/or/file=
#+BEGIN_SRC emacs-lisp
(use-package tramp-hdfs :pin "melpa")
#+END_SRC

* Org-mode
org-mode itself is in the init.el file. here's additional config for it.
I've been having some issues exporting, so I'm actively loading libraries here.
#+BEGIN_SRC emacs-lisp

;; have to do this because org comes preinstalled with emacs
(advice-add 'package-installed-p :around 'package-from-archive)
(use-package org
  :pin "org"
  :ensure org-plus-contrib
  :init
  (setq org-directory stag-org-directory)
  (setq org-id-track-globally t)
  (setq org-id-locations-file "~/.emacs.d/local-files/.org-id-locations"))
(advice-remove 'package-installed-p 'package-from-archive)

(use-package org-macro :ensure nil :after org)
(use-package ob-exp :ensure nil :after org)
(use-package org-compat :ensure nil :after org)
(use-package ox :ensure nil :after org)
(use-package ox-md :ensure nil :after ox)

;; (use-package ox-pandoc)
#+END_SRC
** Generic org-mode configuration
#+BEGIN_SRC emacs-lisp
    (setq org-src-fontify-natively t)
    (add-to-list 'auto-mode-alist '(".org.txt$" . org-mode))

    (setq org-startup-indented t)
    (setq org-cycle-separator-lines 0)
    (setq org-goto-interface 'outline-path-completion) ;; useful with C-c C-j
    (setq org-M-RET-may-split-line '((default .t) (headline . nil)))
#+END_SRC
** Org bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC
** Adding images
#+BEGIN_SRC emacs-lisp
  (use-package org-download)
#+END_SRC
** keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cb" 'org-switchb)
  (org-defkey org-mode-map "\C-cr" 'org-refile)
#+END_SRC
** Calendar
#+begin_src emacs-lisp
  (use-package org-gcal
    :pin "melpa"
    :after org-agenda
    :init
    (setq persist--directory-location "~/.emacs.d/local-files/")
    (setq org-gcal-dir "~/.emacs.d/local-files/org-gcal/"))

  (use-package calfw-gcal :pin "melpa"
    :after calfw-org)

  (use-package calfw-org
    :after (org-gcal calfw)
    :config
    (require 'calfw-org))

  (use-package calfw
    :config
    (setq cfw:fchar-junction ?╋
          cfw:fchar-vertical-line ?┃
          cfw:fchar-horizontal-line ?━
          cfw:fchar-left-junction ?┣
          cfw:fchar-right-junction ?┫
          cfw:fchar-top-junction ?┯
          cfw:fchar-top-left-corner ?┏
          cfw:fchar-top-right-corner ?┓))
#+end_src
* GTD (Getting Things Done)
#+BEGIN_SRC emacs-lisp

  (use-package org-gtd
    :after org
    :demand t
    :pin melpa
    :custom
    ;; where org-gtd will put its files. This value is also the default one.
    (org-gtd-directory stag-org-gtd-directory)
    ;; package: https://github.com/Malabarba/org-agenda-property
    ;; this is so you can see who an item was delegated to in the agenda
    (org-agenda-property-list '("DELEGATED_TO"))
    ;; I think this makes the agenda easier to read
    (org-agenda-property-position 'next-line)
    ;; package: https://www.nongnu.org/org-edna-el/
    ;; org-edna is used to make sure that when a project task gets DONE,
    ;; the next TODO is automatically changed to NEXT.
    (org-edna-use-inheritance t)
    (org-edna-load)
    :bind
    (("C-c d c" . org-gtd-capture) ;; add item to inbox
     ("C-c d a" . org-agenda-list) ;; see what's on your plate today
     ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
     ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
     ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
    :init
    ;; the keybinding to hit when you're done editing an item in the processing phase
    (bind-key "C-c c" 'org-gtd-clarify-finalize))
#+END_SRC
** Agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :ensure nil
    :no-require t
    :after (org-gtd)
    ;; :demand t
    :custom
    (org-agenda-diary-file 'diary-file)
    (org-agenda-include-diary t)
    (org-agenda-restore-windows-after-quit t)
    (org-agenda-sticky t)
    (org-agenda-window-setup 'other-window)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-start-on-weekday nil)
    (org-agenda-files `(,org-gtd-directory))
    (org-agenda-custom-commands '(("g" "Scheduled today and all NEXT items" ((agenda "" ((org-agenda-span 1))) (todo "NEXT"))))))
#+END_SRC
** Diary
#+BEGIN_SRC emacs-lisp
(setq diary-file (concat org-directory "diary-file.org"))

(setq view-diary-entries-initially t
      mark-diary-entries-in-calendar t
      diary-number-of-entries 7)
(add-hook 'diary-display-hook 'diary-fancy-display)
#+END_SRC
** Calendar, dates, times
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1) ;; Monday
(add-hook 'today-visible-calendar-hook 'calendar-mark-today)
#+END_SRC

** Action Tags
These are tags to add to tasks, such as types of action, mindset I need to be in, tool Ι need to have, emotional reward I'll get from doing the action, etc. Whatever helps me pick a task to accomplish.
#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("@home" . ?h)
                        ("@work" . ?w)
                        ("@nonet" . ?n)
                        ("code")))
#+END_SRC
** Captures
#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :ensure nil
    :after org-gtd
    :config
    (setq org-default-notes-file (concat org-directory "notes.org"))

    (setq org-capture-templates `(("i" "Inbox"
                                 entry (file ,(org-gtd--path org-gtd-inbox-file-basename))
                                 "* %?\n%U\n\n  %i"
                                 :kill-buffer t)
                                ("t" "Todo with link"
                                 entry (file ,(org-gtd--path org-gtd-inbox-file-basename))
                                 "* %?\n%U\n\n  %i\n  %a"
                                 :kill-buffer t))))
#+END_SRC
** Refiling
#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes t)
  (setq org-log-refile 'time)
#+END_SRC
** references - org-roam
#+BEGIN_SRC emacs-lisp
(use-package org-roam
      :pin melpa
      :after org
      :init
      (setq org-roam-db-location stag-org-roam-db-location)
      :hook
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory stag-org-roam-directory)
      :bind
      ("C-c n l" . org-roam)
      ("C-c n t" . org-roam-today)
      ("C-c n f" . org-roam-find-file)
      ("C-c n i" . org-roam-insert)
      ("C-c n g" . org-roam-show-graph))
#+END_SRC
* Version control
** Git
*** Editing various git files
#+BEGIN_SRC emacs-lisp
(use-package gitconfig-mode)
#+END_SRC
*** Walking through a file's history
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine)
#+END_SRC
*** Magit
Magit is a pretty amazing interface to git.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-c g" . magit-status)
  :config (setq magit-last-seen-setup-instructions "1.4.0")
          (setq magit-completing-read-function 'magit-builtin-completing-read)
          (setq magit-popup-use-prefix-argument 'default))
#+END_SRC
**** Magit + gitflow
With this configuration, using C-f in a status buffer will trigger the gitflow selectors.
#+BEGIN_SRC emacs-lisp
(use-package magit-gitflow
  :after magit
  :config (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
#+END_SRC
* Programming
** TODO get a LSP configuration going in here
** Folding code
#+BEGIN_SRC emacs-lisp
  (use-package origami
    :pin "melpa"
    :config (global-origami-mode))
#+END_SRC
** Indentation
Always spaces. Always.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq backward-delete-char-untabify-method 'untabify)
#+END_SRC
** code tagging
This is using GNU Global.
#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :config
  (setq tags-case-fold-search nil)
  :bind ("<f7>" . ggtags-create-tags))
#+END_SRC
** Basic changes I want made to any code buffer
Makes it easy to type things like {} or [] or () and magically add an extra line between the two so you can type there
#+BEGIN_SRC emacs-lisp
;; This function comes from http://stackoverflow.com/a/22109370/234025
(defun stag-enter-key-dwim ()
  "Inserts an extra newline between matching separators(?) and indents it, if it can, otherwise behaves like normal enter key"
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{") (looking-at "}"))
                             (and (looking-back ">") (looking-at "<"))
                             (and (looking-back "(") (looking-at ")"))
                             (and (looking-back "\\[") (looking-at "\\]")))))
    (comment-indent-new-line)
    (when break-open-pair
      (save-excursion
        (comment-indent-new-line))
       (indent-for-tab-command))))
#+END_SRC

Here's where I plug in every modification I want in a code buffer
#+BEGIN_SRC emacs-lisp
(use-package smartparens)

(defun stag-code-modes-hook ()
  "A couple of changes I like to make to my code buffers"
;;    (projectile-mode)
    (linum-mode t)
    (smartparens-mode)
    (yas-minor-mode)
;;    (ggtags-mode)
    (add-hook 'before-save-hook 'whitespace-cleanup)
    (local-set-key "\C-m" 'stag-enter-key-dwim))

(add-hook 'prog-mode-hook 'stag-code-modes-hook)
#+END_SRC
** 80-column limit
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :config
  (setq fci-rule-column 80)
  (add-hook 'prog-mode-hook 'fci-mode))
#+END_SRC
** Expand region
One of the features that makes IDEA's editors awesome is the way you can expand selection. This plugin replicates the feature.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C-c <up>" . er/expand-region)
           ("C-c <down>" . er/contract-region)))
#+END_SRC
** Log files
Auto-tail, please.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.log\\'" . auto-revert-mode))
#+END_SRC
** Cucumber
#+BEGIN_SRC emacs-lisp
(use-package feature-mode)
#+END_SRC
** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker-compose-mode)
(use-package docker-tramp)
(use-package dockerfile-mode)
#+END_SRC
** emacs lisp
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :init
    (add-hook 'lisp-mode-hook 'paredit-mode)
    (add-hook 'emacs-lisp-mode-hook 'paredit-mode))

  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC
** Elm
#+BEGIN_SRC emacs-lisp
(use-package elm-mode)
#+END_SRC
** Elixir
#+BEGIN_SRC emacs-lisp
  (use-package elixir-mode
    :after projectile
    :config
    (setq projectile-globally-ignored-directories
    (cons ".elixir_ls" projectile-globally-ignored-directories)))

  (use-package elixir-yasnippets
    :after elixir-mode)
#+END_SRC
** CSS
#+BEGIN_SRC emacs-lisp
  (setq css-indent-offset 2)

  (use-package rainbow-mode
    :pin "gnu"
    :init
    (add-hook 'scss-mode-hook 'rainbow-mode)
    (add-hook 'css-mode-hook 'rainbow-mode))

  (use-package scss-mode
    :mode "\\.scss$"
    :init (add-hook 'scss-mode-hook 'flymake-mode))

#+END_SRC
** Golang
*** Golang mode
Let's run tests easily, shall we?
And let's have gofmt chew my code when I save the file.
#+BEGIN_SRC elisp
  (use-package go-mode
    :bind (:map go-mode-map
                ("C c r s" . go-test-current-file))
    :init
    (defun stag-go-mode ()
      (add-hook 'before-save-hook 'gofmt-before-save nil t)) ;; chew my code
    (add-hook 'go-mode-hook 'stag-go-mode))

(use-package company-go
  :after (go-mode company)
  :config (set (make-local-variable 'company-backends) '(company-go)))
#+END_SRC
*** TODO Packages to be added
- (use-package go-eldoc)
- (use-package go-playground)
- (use-package go-projectile)
- (use-package gore-mode)
- (use-package gorepl-mode)
- (use-package gotest)
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package intero :pin "melpa-stable")
#+END_SRC
** HTML
*** Web-mode                                               :external:major:
Here are all the extensions where I want web-mode enabled
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)

  (use-package web-mode
    :after flycheck
    :mode "\\.mustache$" "\\.html$" "\\.erb$" "\\.jsx$" "\\.eex$" "\\.php$"
    :config
    (flycheck-define-checker eslint-checker
      "A JSX syntax and style checker based on JSXHint."

      :command ("eslint" source)
      :error-patterns
      ((error line-start (1+ nonl) ": line " line ", col " column ", " (message) line-end))
      :modes (web-mode))

    (add-hook 'web-mode-hook
              (lambda ()
                (when (equal web-mode-content-type "jsx")
                  ;; enable flycheck
                  (flycheck-select-checker 'eslint-checker)
                  (flycheck-mode))))

    ;; And I think all this should be indented with 2 spaces.
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-indent-style 2)

    ;; for better jsx syntax-highlighting in web-mode
    ;; - courtesy of Patrick @halbtuerke
    (defadvice web-mode-highlight-part (around tweak-jsx activate)
      (if (equal web-mode-content-type "jsx")
        (let ((web-mode-enable-part-face nil))
          ad-do-it)
        ad-do-it)))

(use-package company-web
      :after web-mode
      :config
      (add-to-list 'company-backends 'company-web-html)
      (add-to-list 'company-backends 'company-web-jade)
      (add-to-list 'company-backends 'company-web-slim))

  (use-package emmet-mode
    :after web-mode
    :init
    (add-hook 'html-mode-hook 'emmet-mode)
    (add-hook 'web-mode-hook 'emmet-mode))

#+END_SRC
** Javascript
*** Actual JS
**** js2-mode                                             :major:external:
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js$"
    :init
    (add-hook 'js2-mode-hook 'stag-code-modes-hook)
    :config
    (setq js2-basic-offset 2)
    (setq js2-bounce-indent-p nil) ;; if I want to toggle indentation
    (setq js2-highlight-level 3))
#+END_SRC
**** tern-mode
https://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring
#+BEGIN_SRC emacs-lisp
(use-package tern
  :init (add-hook 'js2-mode-hook 'tern-mode)
  :config)

(defun delete-tern-process ()
  (interactive)
  (delete-process "Tern"))
#+END_SRC
**** TODO inferior mode (Pick one? Keep both?)
#+BEGIN_SRC emacs-lisp
  (use-package js-comint)
  (use-package nodejs-repl)
#+END_SRC
**** snippets
#+BEGIN_SRC emacs-lisp
  (use-package react-snippets
    :pin "melpa")
#+END_SRC
*** json-mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode :mode "\\.babelrc$")
(use-package json-reformat)
#+END_SRC
*** Typescript
**** REPL
#+BEGIN_SRC emacs-lisp
(use-package tide)
#+END_SRC
**** On-the-fly checking
#+BEGIN_SRC emacs-lisp
  (use-package tss
    :config
    (setq tss-popup-help-key "C-:")
    (setq tss-jump-to-definition-key "C->")
    (setq tss-implement-definition-key "C-c i")
    (tss-config-default))
#+END_SRC
**** Typescript major mode
#+BEGIN_SRC emacs-lisp
(use-package typescript-mode :pin "melpa"
  :init
  (add-hook 'typescript-mode-hook 'flymake-mode))
#+END_SRC
** Lisp
*** TODO Slime [ add quicklisp directory to the top of this file ]
#+BEGIN_SRC emacs-lisp
(use-package slime
  :config
  ;; (load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; ;; Replace "sbcl" with the path to your implementation
  ;; (setq inferior-lisp-program "clisp")
  )
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
 (use-package elpy
   :config
   (add-hook 'python-mode-hook 'elpy-enable))
(use-package auto-virtualenv
  :pin "melpa"
  :config
  (add-hook 'python-mode-hook 'auto-virtualenv-set-virtualenv)
  (add-hook 'projectile-after-switch-project-hook  'auto-virtualenv-set-virtualenv))
#+END_SRC
** Ruby
*** Enh-ruby-mode
There's a few extra things I want started when I open a Ruby buffer
#+BEGIN_SRC emacs-lisp
  (defun stag-ruby-mode-hook ()
    (use-package ruby-refactor
      :diminish "rrf"
      :pin "melpa")
    (ruby-refactor-mode-launch)
    (inf-ruby-minor-mode)
    (modify-syntax-entry ?: ".") ;; Adds ":" to the word definition
    (rbenv-use-corresponding))

  (use-package enh-ruby-mode
    :pin "melpa"
    :interpreter "ruby"
    :mode "\\.rb$" "Guardfile" "\\.rake$" "\\.pryrc$" "Rakefile" "Capfile" "Gemfile" "\\.ru$"
    :init
    (setq enh-ruby-bounce-deep-indent t)
    (add-hook 'enh-ruby-mode-hook 'stag-code-modes-hook)
    (add-hook 'enh-ruby-mode-hook 'stag-ruby-mode-hook))
#+END_SRC
*** Project management
**** rbenv
#+BEGIN_SRC emacs-lisp
(use-package rbenv)
#+END_SRC
**** Project navigation
And I like projectile-rails to handle rails projects.
#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :init
   (add-hook 'projectile-mode-hook 'projectile-rails-on))
#+END_SRC
*** Inferior Ruby
And I like pry better than irb, so have inf-ruby use pry.
#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby
    :config
    (setq inf-ruby-default-implementation "pry")
    (use-package company-inf-ruby
      :pin "melpa"
      :config
      (add-to-list 'company-backends 'company-inf-ruby)))
#+END_SRC
*** Snippets
I use yasnippets, and I've downloaded a collection of snippets from here: https://github.com/bmaland/yasnippet-ruby-mode
*** Testing
**** rspec
#+BEGIN_SRC emacs-lisp
(use-package rspec-mode)
#+END_SRC
*** TODO packages to be added
- (use-package bundler)
- (use-package goto-gem)
- (use-package haml-mode)
- (use-package slim-mode)
- (use-package minitest)
- (use-package rbenv)
- (use-package robe)
- (use-package ruby-hash-syntax)
- (use-package ruby-refactor)
- (use-package yaml-mode)
** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :pin "melpa"
    :init
    (add-hook 'rust-mode-hook 'stag-code-modes-hook)
    (add-hook 'rust-mode-hook 'flycheck-mode)
    (add-hook 'rust-mode-hook 'flymake-mode))

    (use-package flycheck-rust
      :after rust-mode
      :pin "melpa")

    (use-package flymake-rust
      :after rust-mode
      :pin "melpa")

    (use-package cargo
      :after rust-mode)
#+END_SRC
** Shells
*** Generic shell things
**** TODO setup for shell
try ~native-complete~
**** Existing
#+BEGIN_SRC emacs-lisp
  (use-package shell-command
    :pin "melpa"
    :init (add-hook 'shell-mode-hook 'shell-command-completion-mode))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package xterm-color
  :config
  (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter)
  (setq comint-output-filter-functions (remove 'ansi-color-process-output comint-output-filter-functions)))
#+END_SRC
*** Bash
#+BEGIN_SRC emacs-lisp
  (setq explicit-bash-args '("--noediting" "--login" "-i"))
  (require 'em-smart)

  (use-package bash-completion :config (bash-completion-setup))

  ;; (defadvice ansi-term (after advise-ansi-term-coding-system)
  ;;     (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  ;; (ad-activate 'ansi-term)
#+END_SRC
*** Eshell
#+BEGIN_SRC emacs-lisp
(defun eshell/clear ()
  "Clear the eshell buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(use-package eshell-did-you-mean
  :config
  (eshell-did-you-mean-setup))
#+END_SRC
*** Fish
#+BEGIN_SRC emacs-lisp
(use-package fish-mode)
#+END_SRC
** SQL
*** sqlup                                                  :minor:external:
auto-upcase SQL keywords as I type, please.
#+BEGIN_SRC emacs-lisp
(use-package sqlup-mode
  :init
  (add-hook 'sql-mode-hook 'sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode))
#+END_SRC
** tintin
I maintain a tintin++ config, so this is at least convenient.
#+BEGIN_SRC emacs-lisp
(use-package tintin-mode :pin "marmalade")
#+END_SRC
* Writing
** Symbols
#+BEGIN_SRC emacs-lisp
(use-package xah-math-input
  :pin "melpa"
  :init
  (add-hook 'text-mode-hook 'xah-math-input-mode)
  (add-hook 'org-mode-hook 'xah-math-input-mode))
#+END_SRC
** COMMENT Fixing typos

Commented out because Ι had some issues writing in more than just English.

Source: http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

#+BEGIN_SRC emacs-lisp
  (define-key ctl-x-map "\C-i"
    #'endless/ispell-word-then-abbrev)

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev. Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer. You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
        (while (if (setq bef (thing-at-point 'word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
                 ;; If there's no word at point, keep looking
                 ;; until `bob'.
                 (not (bobp)))
          (backward-word))
        (setq aft (thing-at-point 'word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))

  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
#+END_SRC
** TeX
#+BEGIN_SRC emacs-lisp
  (require 'flymake)

  (defun flymake-get-tex-args (file-name)
    (list "pdflatex"
          (list "-file-line-error" "-draftmode" "-interaction=nonstopmode" file-name)))


  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq TeX-save-query nil)

  (add-hook 'LaTeX-mode-hook 'flymake-mode)

  (setq ispell-program-name "aspell") ; could be ispell as well, depending on your preferences
  (setq ispell-dictionary "english") ; this can obviously be set to any language your spell-checking program supports

  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-buffer)

  (defun stag-turn-on-outline-minor-mode ()
    (outline-minor-mode 1))

  (add-hook 'LaTeX-mode-hook 'stag-turn-on-outline-minor-mode)
  (add-hook 'latex-mode-hook 'stag-turn-on-outline-minor-mode)
  (setq outline-minor-mode-prefix "\C-c \C-o") ; Or something else
#+END_SRC
** Presentations
*** TODO Slides
**** revealjs
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
  (use-package ox-reveal
    :after htmlize
    :pin "melpa"
    :config
    (setq org-reveal-root stag-org-reveal-root))
#+END_SRC
** Email
*** Add BBDB
#+begin_src emacs-lisp
(use-package bbdb
  :after org
  :config
  (setq bbdb-file stag-bbdb-file)
  (require 'ol-bbdb))
#+end_src
*** Sending email
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'message-user-agent)

(setq smtpmail-stream-type 'ssl
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 465)
#+END_SRC

smtpmail-multi
#+BEGIN_SRC emacs-lisp
  (use-package smtpmail-multi
    :pin "melpa"
    :config
    (setq smtpmail-multi-accounts
          `((home . (,user-mail-address
                     "smtp.gmail.com"
                     587
                     ,user-mail-address
                     starttls
                     nil nil nil))))

    (setq smtpmail-multi-associations
          `((,user-mail-address home)))

    (setq smtpmail-multi-default-account 'home)

    (setq message-send-mail-function 'smtpmail-multi-send-it)

    (setq smtpmail-debug-info t)
    (setq smtpmail-debug-verbose t))
#+END_SRC
*** TODO Sending/Reading/Encrypting email
orgstruct++ was removed in org 9.2
It seems I may want to use orgalist.
#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :after org
  :config
  (require 'ol-notmuch)
  (defun stag-email-hook ()
    (epa-mail-mode))

  (add-hook 'notmuch-message-mode-hook 'stag-email-hook))
#+END_SRC
** Blogging
#+BEGIN_SRC emacs-lisp
  (use-package easy-hugo
    :init
    (setq easy-hugo-org-header t)
    (setq easy-hugo-default-ext ".org")
    (setq easy-hugo-basedir stag-easy-hugo-basedir)
    (setq easy-hugo-url "http://blog.trevoke.net")
    (setq easy-hugo-root stag-easy-hugo-root)
    (setq easy-hugo-previewtime "300"))
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :init
    (add-hook 'markdown-mode-hook 'turn-on-orgtbl))
#+END_SRC
*** TODO Github-Flavored Markdown (requires backend config?)
#+BEGIN_SRC emacs-lisp
(require 'ox-md)
#+END_SRC
*** TODO My orgtbl-to-gfm conversion (obsoleted by above?)
It's quite nice to use an orgtbl, but GFM is weird. This converts to a GFM table. use C-c C-c to generate / update GFM table.
#+BEGIN_SRC emacs-lisp
;;; orgtbl-to-gfm conversion function
;; Usage Example:
;;
;; <!-- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
;; <!-- END RECEIVE ORGTBL $1 -->
;;
;; <!--
;; #+ORGTBL: SEND $1 orgtbl-to-gfm
;; | $0 |
;; -->

(defun orgtbl-to-gfm (table params)
  "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
  (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
                               org-table-last-alignment ""))
         (params2
          (list
           :splice t
           :hline (concat alignment "|")
           :lstart "| " :lend " |" :sep " | ")))
           (orgtbl-to-generic table (org-combine-plists params2 params))))

(defun stag-insert-org-to-gfm-table (table-name)
  (interactive "*sEnter table name: ")
  (insert "<!---
#+ORGTBL: SEND " table-name " orgtbl-to-gfm

-->
<!--- BEGIN RECEIVE ORGTBL " table-name " -->
<!--- END RECEIVE ORGTBL " table-name " -->")
  (previous-line)
  (previous-line)
  (previous-line))

  (global-set-key (kbd "C-c t") 'stag-insert-org-to-gfm-table)
#+END_SRC

* Communication Clients
** IRC
#+BEGIN_SRC emacs-lisp
(setq erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
#+END_SRC
* Dashboard
This is the buffer I see when I start up emacs.
#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda ()
                               (org-agenda nil "g")
                               (delete-other-windows)))
#+end_src
