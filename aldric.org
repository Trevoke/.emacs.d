#+TITLE Trevoke's emacs config
#+OPTIONS: toc:4 h:4

* Configuration
** About
<<babel-init>>
Welcome to my emacs configuration.
I tinker with this file a lot, so I need a quick way to get to it. This is probably one of the worst possible ways to do it.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-<SPC>")
                (lambda () (interactive) (find-file "~/.emacs.d/aldric.org")))
#+END_SRC
** Personal information
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Aldric Giacomoni"
      user-mail-address "trevoke@gmail.com")
#+END_SRC
** Package management
*** The package manager: use-package
I use [[https://github.com/jwiegley/use-package][=use-package=]], because:
1. it is integrated within emacs.
2. it allows me to set up emacs on any OS I desire more easily than other options I've encountered so far
3. it allows me to easily share / steal configuration snippets
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives
             '("marmalade" . "http://marmalade-repo.org/packages/"))
(add-to-list 'package-archives
             '("melpa-stable" . "https://stable.melpa.org/packages/"))

(package-initialize)

;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)

;; This lets use-package install packages that come built-in with emacs, like org-mode
;; (defun package-from-archive (f &rest args)
;;   (and (apply f args)
;;        (assq (car args) package-alist)))

;; (advice-add 'package-installed-p :around 'package-from-archive)
#+END_SRC

*** Configuring the package manager
I default to melpa-stable.
#+BEGIN_SRC emacs-lisp
(setq use-package-always-pin "melpa-stable")
(setq use-package-always-ensure t)
#+END_SRC

*** A new package browser
#+BEGIN_SRC emacs-lisp
(use-package paradox)
#+END_SRC
** Additional paths
*** Themes
#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
(load-theme 'mejelly t)
#+END_SRC
*** Packages (without package manglement)
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages")
#+END_SRC
*** TODO Secrets (configure paradox)
API keys, passwords, etc are kept in here. This file is .gitignored.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/emacs.secrets" t)
#+END_SRC
*** Customizations from customization system
Keeping these separate makes life easier: they get modified when I load a theme and such, and I don't need that kind of hassle when maintaining my actual configuration, you know?
In addition, I do keep some somewhat computer-specific stuff in there, like the font, and it's just easier to have this separated there.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file t) ;; t means no error if file does not exist
#+END_SRC
** General emacs config (no external packages)
*** Yes/No => y/n
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Visual choices
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(global-hl-line-mode t)
(setq column-number-mode t)
(setq ring-bell-function 'ignore)
(setq visible-bell t)
(setq system-uses-terminfo nil)
#+END_SRC

This shows the file path in the GUI header
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '((:eval (if (buffer-file-name)
                                              (abbreviate-file-name (buffer-file-name)) "%f"))))
#+END_SRC
*** Backups
Centralize emacs backups. This directory is gitignored.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
And I'm not super-worried about old backups and other such things, so I'll just tell emacs to stop worrying about it.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
*** History
Stolen from http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html#sec-10-3-2
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
*** TODO Window config (Put OSX stuff somewhere else)
I don't really care about any of the extra details - emacs helps me out enough in other ways.
#+BEGIN_SRC emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC
Although of course if you're on OSX, at least the menu bar can be enabled since the mighty OSX top bar won't ever disappear.
And I've also added other OSX-specific stuff here... For now.
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
    (use-package exec-path-from-shell
      :config
      (exec-path-from-shell-initialize))
    (setq ns-use-srgb-colorspace t)
    (menu-bar-mode t))
#+END_SRC
*** UTF-8
#+BEGIN_SRC emacs-lisp
;; Activate UTF-8 mode:
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; 2013-12-10 IRC #Emacs
(set-clipboard-coding-system 'utf-8)

;; http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/
;; in addition to the lines above:

(set-default-coding-systems 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC
*** Buffer management
I like unique buffer names. Enter uniquify.
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq
  uniquify-buffer-name-style 'post-forward
  uniquify-separator ":")
#+END_SRC
Also, ibuffer is nicer than plain-old buffer window
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer-other-window)
(setq ibuffer-default-sorting-mode 'major-mode)
#+END_SRC
*** Window management
The package switch-window shows you a number for each buffer, making it simple to go to the one you care about.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :bind ("C-x o" . switch-window))
#+END_SRC
Taken from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury
#+BEGIN_SRC emacs-lisp
(defun stag-vsplit-last-buffer (prefix)
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (unless prefix
          (switch-to-next-buffer)))

(defun stag-hsplit-last-buffer (prefix)
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (unless prefix
    (switch-to-next-buffer)))

(global-set-key (kbd "C-x 2") 'stag-vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'stag-hsplit-last-buffer)
#+END_SRC
*** Scrolling
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 5
      scroll-preserve-screen-position 1)
#+END_SRC
** Interacting with emacs
*** TODO Folding code (origami-mode please)
*** Disable C-z to minimize
Suspend emacs？ I'll use C-x C-z.
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-z"))
#+END_SRC
*** Fuzzy matching
Enter smex. I like typing "plp" to get to "package-list-packages".
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :config
    (smex-initialize)
    (setq smex-auto-update t)
    :bind (("C-x C-m" . smex)
           ("C-x m" . smex-major-mode-commands)))
#+END_SRC
*** Fonts and stuff
I found this function online somewhere, before I thought tracking code origin for this config file might matter.
All it does is tell you what face is at point.
#+BEGIN_SRC emacs-lisp
(defun stag-what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC
** TODO Discovering emacs (replace this stuff with icicles)
*** Guide key                                              :minor:external:
emacs is awesome. It's also crazy, crazy full-featured. This plugin lets you examine what's behind the door of a key prefix.
#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :config
    (setq guide-key/guide-key-sequence
          '("C-x r"
            "C-x 4"
            "C-h"
            "C-c"
            "C-x" "C-x a" "C-x C-a"
            "C-x 8" "C-x 8 \"  " "C-x 8 '" "C-x 8 ~"
            "C-u" "C-u C-x"))
    (guide-key-mode 1))
#+END_SRC
*** Discover                                               :external:minor:
On the topic of discovering emacs.. Discover.el is amazing.
#+BEGIN_SRC emacs-lisp
(use-package discover :config (global-discover-mode 1))
#+END_SRC
** Extending emacs with engines
*** Interface: =ido=
I use IDO and I like it a lot. flx-ido, especially, is basically heaven.
#+BEGIN_SRC emacs-lisp
(ido-mode 1)
(ido-everywhere 1)
(add-to-list 'ido-ignore-files "\\.DS_Store")
(setq ido-use-faces t
      ido-enable-prefix nil
      ido-enable-flex-matching t
      ido-case-fold t ;; ignore case
      ido-create-new-buffer 'always ;; easily create files
      ido-use-filename-at-point nil ;; don't try to be smart
)
(setq ido-auto-merge-delay-time 7) ;; Default: 0.7

(use-package ido-ubiquitous
             :config
             (ido-ubiquitous-mode)
             (setq org-completion-use-ido t)
             (setq magit-completing-read-function 'magit-ido-completing-read))
(use-package ido-vertical-mode :config (ido-vertical-mode 1))
(use-package flx-ido :config (flx-ido-mode 1))
#+END_SRC

*** Completion
**** Auto-complete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :config
    (require 'auto-complete-config)
    (ac-config-default)
    (use-package ac-dabbrev
      :config
      (add-to-list 'ac-sources 'ac-source-dabbrev)
      (defun ac-dabbrev-expand ()
        (interactive)
        (auto-complete '(ac-source-dabbrev)))
      (global-set-key (kbd "M-/") 'ac-dabbrev-expand)))
#+END_SRC
**** Snippets
Snippets; when you've tried 'em, it's hard to do without 'em. I mean, keystrokes, who needs 'em, right?
#+BEGIN_SRC emacs-lisp
(use-package yasnippet :config (yas-global-mode 1))
#+END_SRC
*** Project navigation
Projectile is pretty sweet.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (use-package grizzl)
  :config
  (projectile-global-mode)
  (setq projectile-completion-system 'grizzl))
#+END_SRC
*** Searching
**** Anzu (about search results)                          :external:minor:
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :config (global-anzu-mode t)
    :bind (("M-%" . anzu-query-replace)
           ("C-M-%" . anzu-query-replace-regexp)))
#+END_SRC
**** Silver searcher + Wgrep-ag
Sometimes after you've found a bunch of things, you want to edit.. Kind of a find-and-replace sort of deal, maybe?
#+BEGIN_SRC emacs-lisp
(use-package ag
  :config
  (use-package wgrep-ag
    :ensure wgrep
    :init  (add-hook 'ag-mode-hook 'wgrep-ag-setup)
    :config (autoload 'wgrep-ag-setup "wgrep-ag")))
#+END_SRC
** Org-mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :pin melpa
    :config
    (use-package org-bullets
      :init (add-hook 'org-mode-hook 'org-bullets-mode)))
#+END_SRC
I've been having some issues exporting, so I'm actively loading libraries here.
#+BEGIN_SRC emacs-lisp
(load-library "org-macro")
(load-library "ob-exp")
(load-library "org")
(load-library "org-compat")
(load-library "ox")
#+END_SRC
Org-mode is nowadays a BIG part of what I do with emacs...
**** First, Github-Flavored Markdown
It's quite nice to use an orgtbl, but GFM is weird. This converts to a GFM table. use C-c C-c to generate / update GFM table.
#+BEGIN_SRC emacs-lisp
;;; orgtbl-to-gfm conversion function
;; Usage Example:
;;
;; <!-- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
;; <!-- END RECEIVE ORGTBL $1 -->
;;
;; <!--
;; #+ORGTBL: SEND $1 orgtbl-to-gfm
;; | $0 |
;; -->

(defun orgtbl-to-gfm (table params)
  "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
  (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
                               org-table-last-alignment ""))
         (params2
          (list
           :splice t
           :hline (concat alignment "|")
           :lstart "| " :lend " |" :sep " | ")))
           (orgtbl-to-generic table (org-combine-plists params2 params))))

(defun stag-insert-org-to-gfm-table (table-name)
  (interactive "*sEnter table name: ")
  (insert "<!---
#+ORGTBL: SEND " table-name " orgtbl-to-gfm

-->
<!--- BEGIN RECEIVE ORGTBL " table-name " -->
<!--- END RECEIVE ORGTBL " table-name " -->")
  (previous-line)
  (previous-line)
  (previous-line))

  (global-set-key (kbd "C-c t") 'stag-insert-org-to-gfm-table)
#+END_SRC
**** Generic org-mode configuration
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
(add-to-list 'auto-mode-alist '(".org.txt$" . org-mode))

(setq org-directory "~/Google Drive/notes")
(setq org-default-notes-file (concat org-directory "/notes.org.txt"))
(define-key global-map "\C-cc" 'org-capture)

(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)

(setq org-startup-indented t)
(setq org-log-done 'time)

(setq org-todo-keywords '( "TODO(t)" "WAIT(w)" "|" "DONE" "CANCELED(c)"))
(setq org-tag-alist '(("@home" . ?h) ("@work" . ?w) ("family") ("weiqi") ("ruby") ("lisp") ("emacs")))

(setq org-mobile-directory "~/Dropbox/orgnotes")
(setq org-mobile-inbox-for-pull "~/Google Drive/notes/from-mobile.org")
#+END_SRC

**** Left mouse-click to org-cycle
What? My hands aren't ALWAYS on the keyboard.
This is currently disabled.
#+BEGIN_SRC emacs-lisp
;; (defun stag-click-to-cycle-org-visibility ()
;;   (local-set-key [mouse-1] 'org-cycle))
;; (add-hook 'org-mode-hook 'stag-click-to-cycle-org-visibility)
#+END_SRC
*** Olivetti                                               :external:minor:
#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :init
  (add-hook 'org-mode-hook 'turn-on-olivetti-mode)
  :config
  (setq olivetti-body-width 80))
#+END_SRC
*** Markdown                                               :major:external:
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :init
    (add-hook 'markdown-mode-hook 'turn-on-orgtbl))
#+END_SRC
*** Blogging
#+BEGIN_SRC emacs-lisp
  (use-package org-page
    :config
    (setq op/repository-directory "~/src/projects/trevoke.github.io")
    (setq op/personal-github-link "https://github.com/trevoke")
    (setq op/site-domain "http://blog.trevoke.net/")
    (setq op/site-main-title "Seven Steps")
    (setq op/site-sub-title "Words... words, they're all we have to go on! — Rosencrantz and Guildenstern are dead"))
#+END_SRC
*** TODO Presentations (org-reveal? org-ioslide?)
** Writing (specs, docs, blogs...)
*** Interacting with text
**** More fine-grained word-by-word navigation
#+BEGIN_SRC emacs-lisp
(use-package syntax-subword :config (syntax-subword-mode))
#+END_SRC
**** Use visual-line-mode
#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC
**** Redefine kill-region and backward-kill-word
I used Bash for a long time. This allows me to keep using Ctrl-w to delete a word backward.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-x C-k") 'kill-region)
#+END_SRC
**** TODO Move down real line by real line (do I kill this?)
#+BEGIN_SRC emacs-lisp
(setq line-move-visual nil)
#+END_SRC
**** Sentences end with a single space
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Inserting new lines before/after current one
#+BEGIN_SRC emacs-lisp
(defun stag-insert-line-below ()
  "Insert and auto-indent line below cursor, like in vim."
  (interactive)
  (move-end-of-line 1)
  (open-line 1)
  (next-line)
  (indent-for-tab-command))

(defun stag-insert-line-above ()
  "Insert and auto-indent line above cursor, like in vim."
  (interactive)
  (previous-line)
  (move-end-of-line 1)
  (stag-insert-line-below))

(global-set-key (kbd "C-o") 'stag-insert-line-below)
(global-set-key (kbd "C-M-o") 'stag-insert-line-above)
#+END_SRC

*** Symbols
#+BEGIN_SRC emacs-lisp
(use-package xah-math-input
  :init
  (add-hook 'text-mode-hook 'xah-math-input-mode)
  (add-hook 'org-mode-hook 'xah-math-input-mode))
#+END_SRC
*** COMMENT Fixing typos
Source: http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

#+BEGIN_SRC emacs-lisp
  (define-key ctl-x-map "\C-i"
    #'endless/ispell-word-then-abbrev)

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev. Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer. You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
        (while (if (setq bef (thing-at-point 'word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
                 ;; If there's no word at point, keep looking
                 ;; until `bob'.
                 (not (bobp)))
          (backward-word))
        (setq aft (thing-at-point 'word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))

  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
#+END_SRC
** Version control
*** Git
**** Editing various git files
#+BEGIN_SRC emacs-lisp
(use-package gitconfig-mode)
#+END_SRC
**** Walking through a file's history
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine)
#+END_SRC
**** Magit                                                :external:minor:
Magit is a pretty amazing interface to git.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-c g" . magit-status)
  :config (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC
***** Magit + gitflow
With this configuration, using C-f in a status buffer will trigger the gitflow selectors.
#+BEGIN_SRC emacs-lisp
(use-package magit-gitflow
  :config (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
#+END_SRC
***** Github pull requests
This will let us handle pull requests through Github.
| key | behavior                                        |
|-----+-------------------------------------------------|
| # g | refresh list of PRs                             |
| # f | fetch commits for PR                            |
| # b | create topic branch for PR                      |
| # m | merge PR on top of currently checked out branch |
| # c | create new pull request                         |
| # o | open PR in browser                              |
| j q | jump to PR section in magit-status              |
|-----+-------------------------------------------------|
#+BEGIN_SRC emacs-lisp
(use-package magit-gh-pulls
  :config (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls))
#+END_SRC
** Programming
*** Indentation
Always spaces. Always.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
*** code tagging                                           :external:minor:
This is the ggtags plugin, which uses GNU Global.
#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :config
  (setq tags-case-fold-search nil)
  :bind ("<f7>" . ggtags-create-tags))
#+END_SRC
*** Basic changes I want made to any code buffer
Makes it easy to type things like {} or [] or () and magically add an extra line between the two so you can type there
#+BEGIN_SRC emacs-lisp
;; This function comes from http://stackoverflow.com/a/22109370/234025
(defun stag-enter-key-dwim ()
  "Inserts an extra newline between matching separators(?) and indents it, if it can, otherwise behaves like normal enter key"
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{") (looking-at "}"))
                             (and (looking-back ">") (looking-at "<"))
                             (and (looking-back "(") (looking-at ")"))
                             (and (looking-back "\\[") (looking-at "\\]")))))
    (comment-indent-new-line)
    (when break-open-pair
      (save-excursion
        (comment-indent-new-line))
       (indent-for-tab-command))))
#+END_SRC

Here's where I plug in every modification I want in a code buffer
#+BEGIN_SRC emacs-lisp
(use-package smartparens)
(use-package auto-complete)

(defun stag-code-modes-hook ()
  "A couple of changes I like to make to my code buffers"
;;    (projectile-mode)
    (linum-mode t)
    (smartparens-mode)
    (auto-complete-mode)
    (ggtags-mode)
    (eldoc-mode)
    (add-hook 'before-save-hook 'whitespace-cleanup)
    (local-set-key "\C-m" 'stag-enter-key-dwim))
    ;;(local-set-key "\C-m" 'newline-and-indent))

(add-hook 'prog-mode-hook 'stag-code-modes-hook)
#+END_SRC
*** Expand region                                          :external:minor:
One of the features that makes IDEA's editors awesome is the way you can expand selection. This plugin replicates the feature.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C-c <up>" . er/expand-region)
           ("C-c <down>" . er/contract-region)))
#+END_SRC
*** Log files
Auto-tail, please.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.log\\'" . auto-revert-mode))
#+END_SRC
*** C#
#+BEGIN_SRC emacs-lisp
(defun stag-csharp-mode-hook ()
  (setq c-basic-offset 4))

(use-package csharp-mode
  :defer t
  :init
  (add-hook 'csharp-mode-hook 'stag-csharp-mode-hook))
#+END_SRC
*** emacs lisp
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :init
    (add-hook 'lisp-mode-hook 'paredit-mode)
    (add-hook 'emacs-lisp-mode-hook 'paredit-mode))

  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC
*** Elixir
#+BEGIN_SRC emacs-lisp
  (use-package alchemist
    :config
    (use-package elixir-yasnippets)
    (use-package flymake-elixir
      :init (add-hook 'elixir-mode-hook 'flymake-mode)))
#+END_SRC
*** CSS
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :init
    (add-hook 'scss-mode-hook 'rainbow-mode)
    (add-hook 'css-mode-hook 'rainbow-mode))

  (use-package scss-mode
    :mode "\\.scss$"
    :init (add-hook 'scss-mode-hook 'flymake-mode))

#+END_SRC
*** Golang
**** Golang mode
Let's run tests easily, shall we?
And let's have gofmt chew my code when I save the file.
#+BEGIN_SRC elisp
  (use-package go-mode
    :bind (:map go-mode-map
                ("C c r s" . go-test-current-file))
    :init
    (defun stag-go-mode ()
      (add-hook 'before-save-hook 'gofmt-before-save nil t)) ;; chew my code
    (add-hook 'go-mode-hook 'stag-go-mode)
    :config
    (use-package go-autocomplete
      :init (add-hook 'go-mode-hook 'auto-complete-for-go)))
#+END_SRC
**** TODO Packages to be added
- (use-package go-eldoc)
- (use-package go-playground)
- (use-package go-projectile)
- (use-package gore-mode)
- (use-package gorepl-mode)
- (use-package gotest)
*** HTML
**** Web-mode                                           :external:major:
Here are all the extensions where I want web-mode enabled
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.mustache$" "\\.html$" "\\.erb$"
    :config
    ;; I want to use auto-complete with the ac-html source when in web-mode
    (use-package ac-html
      :config
      (add-to-list 'web-mode-ac-sources-alist
                   '("html" . (ac-source-html-attribute-value
                               ac-source-html-tag
                               ac-source-html-attribute))))

    ;; And I think all this should be indented with 4 spaces.
    (setq web-mode-markup-indent-offset 4)
    (setq web-mode-css-indent-offset 4)
    (setq web-mode-code-indent-offset 4)
    (setq web-mode-indent-style 4))

  (use-package emmet-mode
    :init
    (add-hook 'html-mode-hook 'emmet-mode)
    (add-hook 'web-mode-hook 'emmet-mode))

#+END_SRC
*** Javascript
**** js2-mode                                             :major:external:
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js$"
    :mode ("\\.jsx$" . js2-jsx-mode)
    :init (add-hook 'js2-mode-hook 'stag-code-modes-hook)
    :config
    (setq js2-basic-offset 2)
    (setq js2-bounce-indent-p nil) ;; if I want to toggle indentation
    (setq js2-highlight-level 3)
    (use-package ac-js2
      :init (add-hook 'js2-mode-hook 'ac-js2-mode)))
#+END_SRC
**** TODO inferior mode (Pick one? Keep both?)
#+BEGIN_SRC emacs-lisp
  (use-package js-comint)
  (use-package nodejs-repl)
#+END_SRC
**** json-mode
#+BEGIN_SRC emacs-lisp
(use-package json-mode :mode "\\.babelrc$")
(use-package json-reformat)
#+END_SRC
*** Ruby
**** Enh-ruby-mode
There's a few extra things I want started when I open a Ruby buffer
#+BEGIN_SRC emacs-lisp
  (defun stag-ruby-mode-hook ()
    (ruby-refactor-mode-launch)
    (inf-ruby-minor-mode)
    (modify-syntax-entry ?: ".") ;; Adds ":" to the word definition
    (rbenv-use-corresponding))

  (use-package enh-ruby-mode
    :interpreter "ruby"
    :mode "\\.rb$" "Guardfile" "\\.rake$" "\\.pryrc$" "Rakefile" "Capfile" "Gemfile" "\\.ru$"
    :init
    (add-hook 'enh-ruby-mode-hook 'stag-code-modes-hook)
    (add-hook 'enh-ruby-mode-hook 'stag-ruby-mode-hook))
#+END_SRC
**** Project navigation
And I like projectile-rails to handle rails projects.
#+BEGIN_SRC emacs-lisp
(use-package projectile-rails
  :init
   (add-hook 'projectile-mode-hook 'projectile-rails-on))
#+END_SRC
**** Inferior Ruby
And I like pry better than irb, so have inf-ruby use pry.
#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby
    :config
    (setq inf-ruby-default-implementation "pry")
    (use-package ac-inf-ruby
      :init (add-hook 'inf-ruby-mode-hook 'ac-inf-ruby-enable)
      :config
      (add-to-list 'ac-modes 'inf-ruby-mode)
      :bind (:map inf-ruby-mode-map
                  ("TAB" . auto-complete))))
#+END_SRC
**** Snippets
I use yasnippets, and I've downloaded a collection of snippets from here: https://github.com/bmaland/yasnippet-ruby-mode
**** TODO packages to be added
- (use-package bundler)
- (use-package goto-gem)
- (use-package haml-mode)
- (use-package slim-mode)
- (use-package minitest)
- (use-package rbenv)
- (use-package robe)
- (use-package rspec-mode)
- (use-package ruby-hash-syntax)
- (use-package ruby-refactor)
- (use-package yaml-mode)
*** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :init
    (add-hook 'rust-mode-hook 'stag-code-modes-hook)
    (add-hook 'rust-mode-hook 'flycheck-mode)
    (add-hook 'rust-mode-hook 'flymake-mode)
    :config
    (use-package flycheck-rust)
    (use-package flymake-rust)
    (use-package cargo))
#+END_SRC
*** Shells
**** Generic shell things
#+BEGIN_SRC emacs-lisp
(use-package shell-command
  :init (add-hook 'shell-mode-hook 'shell-command-completion-mode))
#+END_SRC
**** Bash
#+BEGIN_SRC emacs-lisp
  (setq explicit-bash-args '("--noediting" "--login" "-i"))
  (require 'em-smart)

  (use-package bash-completion :config (bash-completion-setup))

  ;; (defadvice ansi-term (after advise-ansi-term-coding-system)
  ;;     (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  ;; (ad-activate 'ansi-term)
#+END_SRC

**** Slime
#+BEGIN_SRC emacs-lisp
(use-package slime
  :config
  ;; (load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; ;; Replace "sbcl" with the path to your implementation
  ;; (setq inferior-lisp-program "clisp")
  )
#+END_SRC
**** Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell-did-you-mean
  :config
  (add-to-list 'eshell-preoutput-filter-functions
               #'eshell-did-you-mean-output-filter))
#+END_SRC
*** SQL
**** sqlup                                                :minor:external:
auto-upcase SQL keywords as I type, please.
#+BEGIN_SRC emacs-lisp
(use-package sqlup-mode
  :init
  (add-hook 'sql-mode-hook 'sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode))
#+END_SRC
** Email
*** TODO Add BBDB
*** TODO Mew (email) (do I stop using mew?)
Mew's config is in ~/.mew.el so you won't see it here. Nee-ner nee-ner nee-----ner.
#+BEGIN_SRC emacs-lisp
  (use-package mew
    :config
    (autoload 'mew "mew" nil t)
    (autoload 'mew-send "mew" nil t)

    ;; Optional setup (Read Mail menu):
    (setq read-mail-command 'mew)

    ;; Optional setup (e.g. C-xm for sending a message):
    (autoload 'mew-user-agent-compose "mew" nil t)
    (if (boundp 'mail-user-agent)
        (setq mail-user-agent 'mew-user-agent))
    (if (fboundp 'define-mail-user-agent)
        (define-mail-user-agent
          'mew-user-agent
          'mew-user-agent-compose
          'mew-draft-send-message
          'mew-draft-kill
          'mew-send-hook))

    (setq mew-use-master-passwd t))
#+END_SRC
*** Sending email
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'message-user-agent)

(setq smtpmail-stream-type 'ssl
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 465)
#+END_SRC

smtpmail-multi
#+BEGIN_SRC emacs-lisp
  (use-package smtpmail-multi
    :config
    (setq smtpmail-multi-accounts
          (quote
           ((stride . ("aldric@stridenyc.com"
                       "smtp.gmail.com"
                       587
                       "aldric@stridenyc.com"
                       starttls
                       nil nil nil))
            (home . ("trevoke@gmail.com"
                     "smtp.gmail.com"
                     587
                     "trevoke@gmail.com"
                     starttls
                     nil nil nil)))))

    (setq smtpmail-multi-associations
          (quote
           (("trevoke@gmail.com" home)
            ("aldric@stridenyc.com" stride))))

    (setq smtpmail-multi-default-account (quote home))

    (setq message-send-mail-function 'smtpmail-multi-send-it)

    (setq smtpmail-debug-info t)
    (setq smtpmail-debug-verbose t))
#+END_SRC
*** Sending/Reading/Encrypting email
#+BEGIN_SRC emacs-lisp
(defun stag-email-hook ()
  (epa-mail-mode)
  (orgstruct++-mode))

(add-hook 'notmuch-message-mode-hook 'stag-email-hook)
#+END_SRC
** Miscellanous
*** Color themes
#+BEGIN_SRC emacs-lisp
(use-package material-theme)
(use-package moe-theme)
(use-package railscasts-theme)
#+END_SRC

*** Whitespace                                             :minor:builtin:
#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-line-column 80) ;; limit line length
(setq whitespace-style '(face trailing tabs lines-tail))
(setq whitespace-global-modes '(not org-mode web-mode "Web" markdown-mode))
(global-whitespace-mode)
#+END_SRC
*** Interface customization
**** Smart mode line
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :config
    (setq sml/theme 'dark)
    (sml/setup))
#+END_SRC
**** Default text scale
This handy little package increases the size of the font in the whole frame.
#+BEGIN_SRC emacs-lisp
(use-package default-text-scale
  :bind (("C-x C-=" . default-text-scale-increase)
         ("C-x C--" . default-text-scale-decrease)))
#+END_SRC
*** Calendar, dates, times
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1) ;; Monday
#+END_SRC
**** Diary
#+BEGIN_SRC emacs-lisp
(setq diary-file "~/Google Drive/diary")

(setq view-diary-entries-initially t
      mark-diary-entries-in-calendar t
      number-of-diary-entries 7)
(add-hook 'diary-display-hook 'diary-fancy-display)
(add-hook 'today-visible-calendar-hook 'calendar-mark-today)
#+END_SRC
**** calfw, the calendar framework
#+BEGIN_SRC emacs-lisp
  (use-package calfw
    :config
    (require 'calfw-cal)
    (require 'calfw-ical)
    (require 'calfw-org)

    (setq cfw:fchar-junction ?╋
          cfw:fchar-vertical-line ?┃
          cfw:fchar-horizontal-line ?━
          cfw:fchar-left-junction ?┣
          cfw:fchar-right-junction ?┫
          cfw:fchar-top-junction ?┯
          cfw:fchar-top-left-corner ?┏
          cfw:fchar-top-right-corner ?┓))
#+END_SRC
***** TODO calfw-gcal
Here is a sample function where you could put your Google Calendar information (mostly so I remember how to create the secret file on a new computer).

#+BEGIN_QUOTE
(defun stag-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Green")
    (cfw:cal-create-source "Orange")
    (cfw:ical-create-source "gcal" "gcal-ics-link" "Blue")
    )))
#+END_QUOTE
*** File system browsing (dired)
dired-jump is awesome (C-x C-j in any buffer)
#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Changed my mind. I prefer seeing just the files:
(add-hook 'dired-mode-hook 'dired-hide-details-mode)

;; Auto-refresh silently
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

This will make org-mode behave kinda like a two-pane file manager: with two direds open, you can copy/rename and the default target will be the other pane.
Using split-window-vertically from the first dired might be required to make this work.
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

It's also nice to have dired with M-< and M-> take you to first and last file
#+BEGIN_SRC emacs-lisp
(require 'dired)
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (next-line 2))

(define-key dired-mode-map
  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (next-line -1))

(define-key dired-mode-map
  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
#+END_SRC
