#+TITLE: Trevoke's emacs config
#+OPTIONS: toc:4 h:4

* Configuration
** About
<<babel-init>>
Welcome to my emacs configuration
** Personal information
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Aldric Giacomoni"
      user-mail-address "trevoke@gmail.com")
#+END_SRC
** Additional paths
This is mostly necessary for things not handled by Cask (which we'll see later down the line)
*** Themes
#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
#+END_SRC
*** Package manglement
I use Cask. I enjoy the declarative, Gemfile- or puppet-like approach.
#+BEGIN_SRC emacs-lisp
(require 'cask "~/.cask/cask.el")
(cask-initialize)
(require 'pallet)
(pallet-mode t)
#+END_SRC
*** Packages (without package manglement)
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages")
#+END_SRC
*** TODO Secrets (configure paradox)
API keys, passwords, etc are kept in here. This file is .gitignored.
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/emacs.secrets" t)
#+END_SRC
*** Customizations from customization system
Keeping these separate makes life easier: they get modified when I load a theme and such, and I don't need that kind of hassle when maintaining my actual configuration, you know?
In addition, I do keep some somewhat computer-specific stuff in there, like the font, and it's just easier to have this separated there.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs-custom.el")
(load custom-file t) ;; t means no error if file does not exist
#+END_SRC
** General emacs config (no external packages)
*** Yes/No => y/n
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Visual choices
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(setq initial-scratch-message nil)
(show-paren-mode t)
(setq show-paren-delay 0)
(global-hl-line-mode t)
(setq column-number-mode t)
(setq ring-bell-function 'ignore)
(setq visible-bell t)
(setq system-uses-terminfo nil)
#+END_SRC

This shows the file path in the GUI header
#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '((:eval (if (buffer-file-name)
                                              (abbreviate-file-name (buffer-file-name)) "%f"))))
#+END_SRC
*** Backups
Centralize emacs backups.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC
And I'm not super-worried about old backups and other such things, so I'll just tell emacs to stop worrying about it.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
*** History
Stolen from http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html#sec-10-3-2
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
*** TODO Window config (Put OSX stuff somewhere else)
I don't really care about any of the extra details - emacs helps me out enough in other ways.
#+BEGIN_SRC emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

Although of course if you're on OSX, at least the menu bar can be enabled since the mighty OSX top bar won't ever disappear.
And I've also added other OSX-specific stuff here... For now.
#+BEGIN_SRC emacs-lisp
(when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize)
  (setq ns-use-srgb-colorspace t)
  (menu-bar-mode t))
#+END_SRC
*** Interacting with text
**** Use visual-line-mode
#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC
**** Redefine kill-region and backward-kill-word
Because ... I'm used to being in a shell, you know?
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-x C-k") 'kill-region)
#+END_SRC
**** Move down real line by real line
#+BEGIN_SRC emacs-lisp
(setq line-move-visual nil)
#+END_SRC
**** Sentences end with a single space
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Text size
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+END_SRC
**** Inserting new lines before/after current one
#+BEGIN_SRC emacs-lisp
(defun stag-insert-line-below ()
  "Insert and auto-indent line below cursor, like in vim."
  (interactive)
  (move-end-of-line 1)
  (open-line 1)
  (next-line)
  (indent-for-tab-command))

(defun stag-insert-line-above ()
  "Insert and auto-indent line above cursor, like in vim."
  (interactive)
  (previous-line)
  (move-end-of-line 1)
  (stag-insert-line-below))

(global-set-key (kbd "C-o") 'stag-insert-line-below)
(global-set-key (kbd "C-M-o") 'stag-insert-line-above)
#+END_SRC

Insert math symbols with shift+space
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'xah-math-input-mode)
(add-hook 'org-mode-hook 'xah-math-input-mode)
#+END_SRC
*** UTF-8
#+BEGIN_SRC emacs-lisp
;; Activate UTF-8 mode:
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

;; 2013-12-10 IRC #Emacs
(set-clipboard-coding-system 'utf-8)

;; http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/
;; in addition to the lines above:

(set-default-coding-systems 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))
;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC
*** Buffer management
I like unique buffer names. Enter uniquify.
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq
  uniquify-buffer-name-style 'post-forward
  uniquify-separator ":")
#+END_SRC
Also, ibuffer is nicer than plain-old buffer window
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer-other-window)
(setq ibuffer-default-sorting-mode 'major-mode)
#+END_SRC
*** Window management
Taken from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury
#+BEGIN_SRC emacs-lisp
(defun stag-vsplit-last-buffer (prefix)
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (unless prefix
          (switch-to-next-buffer)))

(defun stag-hsplit-last-buffer (prefix)
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (unless prefix
    (switch-to-next-buffer)))

(global-set-key (kbd "C-x 2") 'stag-vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'stag-hsplit-last-buffer)
#+END_SRC
*** Scrolling
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 5
      scroll-preserve-screen-position 1)
#+END_SRC
** Interacting with emacs
*** Folding code
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-z")) ;; Suspend emacs？ I'll use C-x C-z.
(global-set-key (kbd "C-z z") 'vimish-fold)
(global-set-key (kbd "C-z i") 'vimish-fold-delete)
#+END_SRC
*** Interface
I use IDO and I like it a lot. flx-ido, especially, is basically heaven.
#+BEGIN_SRC emacs-lisp
;; (ido-mode 1)
;; (ido-ubiquitous 1)
;; (ido-vertical-mode 1)
;; (flx-ido-mode 1)
;; (add-to-list 'ido-ignore-files "\\.DS_Store")
;; (setq ido-use-faces t
;;       ido-enable-prefix nil
;;       ido-enable-flex-matching t
;;       ido-case-fold t ;; ignore case
;;       ido-create-new-buffer 'always ;; easily create files
;;       ido-use-filename-at-point nil ;; don't try to be smart
;; )
;;
;; (setq ido-auto-merge-delay-time 7) ;; Default: 0.7
#+END_SRC

Alright, helm, give me your best shot.
#+BEGIN_SRC emacs-lisp
(require 'helm)
#+END_SRC
**** Appearance
Only pop up at the bottom.

#+BEGIN_SRC emacs-lisp
(setq helm-split-window-in-side-p t)

(add-to-list 'display-buffer-alist
             '("\\`\\*helm.*\\*\\'"
               (display-buffer-in-side-window)
               (inhibit-same-window . t)
               (window-height . 0.4)))

(setq helm-swoop-split-with-multiple-windows nil
        helm-swoop-split-direction 'split-window-vertically
        helm-swoop-split-window-function 'helm-default-display-buffer)

#+END_SRC

Input in header line and hide the mode-lines above.

#+BEGIN_SRC emacs-lisp
(setq helm-echo-input-in-header-line t)

(defvar bottom-buffers nil
  "List of bottom buffers before helm session.
    Its element is a pair of `buffer-name' and `mode-line-format'.")

(defun bottom-buffers-init ()
  (setq-local mode-line-format (default-value 'mode-line-format))
  (setq bottom-buffers
        (cl-loop for w in (window-list)
                 when (window-at-side-p w 'bottom)
                 collect (with-current-buffer (window-buffer w)
                           (cons (buffer-name) mode-line-format)))))


(defun bottom-buffers-hide-mode-line ()
  (setq-default cursor-in-non-selected-windows nil)
  (mapc (lambda (elt)
          (with-current-buffer (car elt)
            (setq-local mode-line-format nil)))
        bottom-buffers))


(defun bottom-buffers-show-mode-line ()
  (setq-default cursor-in-non-selected-windows t)
  (when bottom-buffers
    (mapc (lambda (elt)
            (with-current-buffer (car elt)
              (setq-local mode-line-format (cdr elt))))
          bottom-buffers)
    (setq bottom-buffers nil)))

(defun helm-keyboard-quit-advice (orig-func &rest args)
  (bottom-buffers-show-mode-line)
  (apply orig-func args))


(add-hook 'helm-before-initialize-hook #'bottom-buffers-init)
(add-hook 'helm-after-initialize-hook #'bottom-buffers-hide-mode-line)
(add-hook 'helm-exit-minibuffer-hook #'bottom-buffers-show-mode-line)
(add-hook 'helm-cleanup-hook #'bottom-buffers-show-mode-line)
(advice-add 'helm-keyboard-quit :around #'helm-keyboard-quit-advice)
#+END_SRC
**** File Navigation

Backspace goes to the upper folder if you are not inside a filename,
and Return will select a file or navigate into the directory if
it is one.

#+BEGIN_SRC emacs-lisp
(require 'helm)
(helm-mode 1)
(defun dwim-helm-find-files-up-one-level-maybe ()
  (interactive)
  (if (looking-back "/" 1)
      (call-interactively 'helm-find-files-up-one-level)
    (delete-backward-char 1)))

(define-key helm-read-file-map (kbd "<backsqpace>") 'dwim-helm-find-files-up-one-level-maybe)
(define-key helm-read-file-map (kbd "DEL") 'dwim-helm-find-files-up-one-level-maybe)
(define-key helm-find-files-map (kbd "<backspace>") 'dwim-helm-find-files-up-one-level-maybe)
(define-key helm-find-files-map (kbd "DEL") 'dwim-helm-find-files-up-one-level-maybe)

(defun dwim-helm-find-files-navigate-forward (orig-fun &rest args)
  "Adjust how helm-execute-persistent actions behaves, depending on context"
  (if (file-directory-p (helm-get-selection))
      (apply orig-fun args)
    (helm-maybe-exit-minibuffer)))


(define-key helm-map (kbd "<return>") 'helm-maybe-exit-minibuffer)
(define-key helm-map (kbd "RET") 'helm-maybe-exit-minibuffer)
(define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
(define-key helm-read-file-map (kbd "<return>") 'helm-execute-persistent-action)
(define-key helm-find-files-map (kbd "RET") 'helm-execute-persistent-action)
(define-key helm-read-file-map (kbd "RET") 'helm-execute-persistent-action)

(advice-add 'helm-execute-persistent-action :around #'dwim-helm-find-files-navigate-forward)
#+END_SRC

**** FLX
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm
  (require 'flx)
  (defvar helm-flx-cache (flx-make-string-cache #'flx-get-heatmap-file))
  (defadvice helm-score-candidate-for-pattern
      (around flx-score (candidate pattern) activate preactivate compile)
    (setq ad-return-value
          (or
           (car (flx-score
                 (substring-no-properties candidate)
                 (substring-no-properties pattern)
                 helm-flx-cache))
           0)))

  (defadvice helm-fuzzy-default-highlight-match
      (around flx-highlight (candidate) activate preactivate compile)
    "The default function to highlight matches in fuzzy matching.
It is meant to use with `filter-one-by-one' slot."
    (setq ad-return-value
          (let* ((pair (and (consp candidate) candidate))
                 (display (if pair (car pair) candidate))
                 (real (cdr pair)))
            (with-temp-buffer
              (insert display)
              (goto-char (point-min))
              (if (string-match-p " " helm-pattern)
                  (cl-loop with pattern = (split-string helm-pattern)
                           for p in pattern
                           do (when (search-forward (substring-no-properties p) nil t)
                                (add-text-properties
                                 (match-beginning 0) (match-end 0) '(face helm-match))))
                (cl-loop with pattern = (cdr (flx-score
                                              (substring-no-properties display)
                                              helm-pattern helm-flx-cache))
                         for index in pattern
                         do (add-text-properties
                             (1+ index) (+ 2 index) '(face helm-match))))
              (setq display (buffer-string)))
            (if real (cons display real) display))))

  (setq
   helm-buffers-fuzzy-matching t
   helm-imenu-fuzzy-match t
   helm-recentf-fuzzy-match t
   helm-locate-fuzzy-match nil
   helm-M-x-fuzzy-match t
   helm-semantic-fuzzy-match t))
#+END_SRC
**** Helm-AG-r
#+BEGIN_SRC
(setq helm-ag-r-option-list
      '("-S -U --hidden"
        "-S -U -l"))
#+END_SRC
**** TODO helm-gtags (connect to stag-code-modes-hook?)
#+BEGIN_SRC emacs-lisp
    ;; Enable helm-gtags-mode
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)
    (add-hook 'enh-ruby-mode-hook 'helm-gtags-mode)

    ;; Set key bindings
    (eval-after-load "helm-gtags"
      '(progn
         (define-key helm-gtags-mode-map (kbd "M-t") 'helm-gtags-find-tag)
         (define-key helm-gtags-mode-map (kbd "M-r") 'helm-gtags-find-rtag)
         (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-find-symbol)
         (define-key helm-gtags-mode-map (kbd "M-g M-p") 'helm-gtags-parse-file)
         (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
         (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
         (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)))

#+END_SRC
*** Fuzzy matching
Enter smex. I like typing "plp" to get to "package-list-packages".
#+BEGIN_SRC emacs-lisp
(smex-initialize)
(global-set-key (kbd "C-x C-m") 'helm-M-x)
(global-set-key (kbd "C-x m") 'smex-major-mode-commands)
(setq smex-auto-update t)
#+END_SRC
*** Fonts and stuff
The world begins with this function I found online somewhere. Before I kept track of things.
#+BEGIN_SRC emacs-lisp
(defun stag-what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC
** Discovering emacs
*** Guide key                                              :minor:external:
emacs is awesome. It's also crazy, crazy full-featured. This plugin lets you examine what's behind the door of a key prefix.
#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence
      '("C-x r" "C-x 4" "C-h" "C-c"
              "C-x" "C-x a" "C-x C-a"
              "C-x 8" "C-x 8 \"  " "C-x 8 '" "C-x 8 ~"
              "C-u" "C-u C-x"))
(guide-key-mode 1)
#+END_SRC
*** Discover                                               :external:minor:
On the topic of discovering emacs.. Discover.el is amazing.
#+BEGIN_SRC emacs-lisp
(global-discover-mode 1)
#+END_SRC
** Writing (specs, docs, blogs...)
** Org-mode
You could argue that this should be somewhere else, but heck, org-mode is a BIG part of what I do with emacs...
**** First, Github-Flavored Markdown
It's quite nice to use an orgtbl, but GFM is weird. This converts to a GFM table. use C-c C-c to generate / update GFM table.
#+BEGIN_SRC emacs-lisp
;;; orgtbl-to-gfm conversion function
;; Usage Example:
;;
;; <!-- BEGIN RECEIVE ORGTBL ${1:YOUR_TABLE_NAME} -->
;; <!-- END RECEIVE ORGTBL $1 -->
;;
;; <!--
;; #+ORGTBL: SEND $1 orgtbl-to-gfm
;; | $0 |
;; -->

(defun orgtbl-to-gfm (table params)
  "Convert the Orgtbl mode TABLE to GitHub Flavored Markdown."
  (let* ((alignment (mapconcat (lambda (x) (if x "|--:" "|---"))
                               org-table-last-alignment ""))
         (params2
          (list
           :splice t
           :hline (concat alignment "|")
           :lstart "| " :lend " |" :sep " | ")))
           (orgtbl-to-generic table (org-combine-plists params2 params))))

(defun stag-insert-org-to-gfm-table (table-name)
  (interactive "*sEnter table name: ")
  (insert "<!---
#+ORGTBL: SEND " table-name " orgtbl-to-gfm

-->
<!--- BEGIN RECEIVE ORGTBL " table-name " -->
<!--- END RECEIVE ORGTBL " table-name " -->")
  (previous-line)
  (previous-line)
  (previous-line))

  (global-set-key (kbd "C-c t") 'stag-insert-org-to-gfm-table)
#+END_SRC
**** Generic org-mode configuration
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
(add-to-list 'auto-mode-alist '(".org.txt$" . org-mode))

(setq org-directory "~/Google Drive/notes")
(setq org-default-notes-file (concat org-directory "/notes.org.txt"))
(define-key global-map "\C-cc" 'org-capture)

(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)

(setq org-startup-indented t)
(setq org-log-done 'time)

(setq org-todo-keywords '( "TODO(t)" "WAIT(w)" "|" "DONE" "CANCELED(c)"))
(setq org-tag-alist '(("@home" . ?h) ("@work" . ?w) ("family") ("weiqi") ("ruby") ("lisp") ("emacs")))

(setq org-mobile-directory "~/Dropbox/orgnotes")
(setq org-mobile-inbox-for-pull "~/Google Drive/notes/from-mobile.org")
#+END_SRC

**** Left mouse-click to org-cycle
What? My hands aren't ALWAYS on the keyboard.
This is currently disabled.
#+BEGIN_SRC emacs-lisp
;; (defun stag-click-to-cycle-org-visibility ()
;;   (local-set-key [mouse-1] 'org-cycle))
;; (add-hook 'org-mode-hook 'stag-click-to-cycle-org-visibility)
#+END_SRC
*** Olivetti                                               :external:minor:
#+BEGIN_SRC emacs-lisp
(setq olivetti-body-width 80)
(add-hook 'org-mode-hook 'turn-on-olivetti-mode)
#+END_SRC
*** Markdown                                               :major:external:
#+BEGIN_SRC emacs-lisp
(add-hook 'markdown-mode-hook 'turn-on-orgtbl)
#+END_SRC
*** Blogging
#+BEGIN_SRC emacs-lisp
(require 'org-page)
(setq op/repository-directory "~/src/projects/trevoke.github.io")
(setq op/personal-github-link "https://github.com/trevoke")
(setq op/site-domain "http://blog.trevoke.net/")
(setq op/site-main-title "Seven Steps")
(setq op/site-sub-title "Words... words, they're all we have to go on! — Rosencrantz and Guildenstern are dead")
#+END_SRC
*** org-reveal (presentations)
#+BEGIN_SRC emacs-lisp
(setq org-reveal-root "file:///users/a206468627/src/vendor/reveal.js")
#+END_SRC

** Programming
Always spaces. Always.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
*** Expand region                                          :external:minor:
One of the features that makes IDEA's editors awesome is the way you can expand selection. This plugin replicates the feature.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <up>") 'er/expand-region)
(global-set-key (kbd "C-c <down>") 'er/contract-region)
#+END_SRC
*** Basic changes I want made to any code buffer
#+BEGIN_SRC emacs-lisp
(defun stag-code-modes-hook ()
    (projectile-mode)
    (linum-mode t)
    (smartparens-mode)
    (auto-complete-mode)
    (ggtags-mode)
    (eldoc-mode)
    ;;  (hs-minor-mode t) ;; folding, built-in to emacs
    (add-hook 'before-save-hook 'whitespace-cleanup)
    (local-set-key "\C-m" 'newline-and-indent))

(add-hook 'prog-mode-hook 'stag-code-modes-hook)
#+END_SRC
*** Log files
Auto-tail, please.
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.log\\'" . auto-revert-mode))
#+END_SRC
*** code tagging                                           :external:minor:
This is the ggtags plugin, which uses GNU Global.
#+BEGIN_SRC emacs-lisp
(setq tags-case-fold-search nil)
(global-set-key (kbd "<f7>") 'ggtags-create-tags)
#+END_SRC
*** C#
#+BEGIN_SRC emacs-lisp
(defun stag-csharp-mode-hook ()
  (setq c-basic-offset 4))

(add-hook 'csharp-mode-hook 'stag-csharp-mode-hook)
#+END_SRC
*** emacs lisp (gettin' meta in here)
#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook 'paredit-mode)
(add-hook 'emacs-lisp-mode-hook 'paredit-mode)

(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC
*** CSS
#+BEGIN_SRC emacs-lisp
(defun stag-all-css-modes ()
  (css-mode)
  (rainbow-mode))

(add-to-list 'auto-mode-alist '("\\.css$" . stag-all-css-modes))
(add-to-list 'auto-mode-alist '("\\.scss$" . stag-all-css-modes))
#+END_SRC
*** HTML
**** Web-mode                                           :external:major:
Here are all the extensions where I want web-mode enabled
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
#+END_SRC

Also, I want to use auto-complete with the ac-html source when in web-mode
#+BEGIN_SRC emacs-lisp
(require 'web-mode)
(add-to-list 'web-mode-ac-sources-alist
             '("html" . (ac-source-html-attribute-value
                         ac-source-html-tag
                         ac-source-html-attribute)))
#+END_SRC

And I think all this should be indented with 4 spaces.
#+BEGIN_SRC emacs-lisp
(setq web-mode-markup-indent-offset 4)
(setq web-mode-css-indent-offset 4)
(setq web-mode-code-indent-offset 4)
(setq web-mode-indent-style 4)
#+END_SRC
*** Javascript
**** js2-mode                                             :major:external:
#+BEGIN_SRC emacs-lisp
(setq js2-basic-offset 2)
(setq js2-bounce-indent-p t)

(setq js2-highlight-level 3)

(add-to-list 'auto-mode-alist '(".js$" . js2-mode))
(add-hook 'js2-mode-hook 'stag-code-modes-hook)
(add-hook 'js2-mode-hook 'ac-js2-mode)
#+END_SRC

So, React is a thing, and so are JSX files...
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '(".jsx$" . js2-jsx-mode))
#+END_SRC

*** Ruby
There's a few extra things I want started when I open a Ruby buffer
#+BEGIN_SRC emacs-lisp
(defun stag-ruby-mode-hook ()
  (ruby-refactor-mode-launch)
  (inf-ruby-minor-mode)
  (modify-syntax-entry ?: ".") ;; Adds ":" to the word definition
  (rbenv-use-corresponding))

(add-hook 'enh-ruby-mode-hook 'stag-code-modes-hook)
(add-hook 'enh-ruby-mode-hook 'stag-ruby-mode-hook)
#+END_SRC

And I like projectile-rails to handle rails projects.
#+BEGIN_SRC emacs-lisp
(add-hook 'projectile-mode-hook 'projectile-rails-on)
#+END_SRC

What counts as a ruby buffer anyway? I like enh-ruby-mode better.
#+BEGIN_SRC emacs-lisp
(add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))

(add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("Guardfile" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("\\.rake$" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("\\.pryrc$" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("Rakefile$" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("Capfile$" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("Gemfile$" . enh-ruby-mode))
(add-to-list 'auto-mode-alist '("\\.ru$" . enh-ruby-mode))
#+END_SRC

And I like pry better than irb, so have inf-ruby use pry.
#+BEGIN_SRC emacs-lisp
(require 'inf-ruby)
(add-to-list 'inf-ruby-implementations '("pry" . "pry"))
(setq inf-ruby-default-implementation "pry")
(setq inf-ruby-first-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)> *")
(setq inf-ruby-prompt-pattern "^\\[[0-9]+\\] pry\\((.*)\\)[>*\"'] *")
#+END_SRC

I use yasnippets, and I've downloaded a collection of snippets from here: https://github.com/bmaland/yasnippet-ruby-mode
*** Rust
#+BEGIN_SRC emacs-lisp
(add-hook 'rust-mode-hook 'stag-code-modes-hook)
(add-hook 'rust-mode-hook 'flycheck-mode)
(add-hook 'rust-mode-hook 'flymake-mode)
#+END_SRC
*** Shells
**** Bash
#+BEGIN_SRC emacs-lisp
(setq explicit-bash-args '("--noediting" "--login" "-i"))

(require 'em-smart)

;; TODO is this the reason why completion is wonky?
(require 'bash-completion)
(bash-completion-setup)

(defadvice ansi-term (after advise-ansi-term-coding-system)
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(ad-activate 'ansi-term)
#+END_SRC

**** Slime
#+BEGIN_SRC emacs-lisp
  ;; (load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; ;; Replace "sbcl" with the path to your implementation
  ;; (setq inferior-lisp-program "clisp")
#+END_SRC
**** Eshell
#+BEGIN_SRC emacs-lisp
  (add-to-list 'eshell-preoutput-filter-functions
               #'eshell-did-you-mean-output-filter)
#+END_SRC
*** SQL
**** sqlup                                                :minor:external:
auto-upcase SQL keywords as I type, please.
#+BEGIN_SRC emacs-lisp
(add-hook 'sql-mode-hook 'sqlup-mode)
(add-hook 'sql-interactive-mode-hook 'sqlup-mode)
#+END_SRC

*** Project navigation
**** projectile                                           :minor:external:
#+BEGIN_SRC emacs-lisp
(require 'projectile)
(projectile-global-mode)
(setq projectile-completion-system 'grizzl)
#+END_SRC
*** Git
**** Magit                                                :external:minor:
Magit is a pretty amazing interface to git.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "\C-c g") 'magit-status)
(setq magit-last-seen-setup-instructions "1.4.0") ;; magit auto-reverts unmodified buffers
#+END_SRC
*** Snippets
Snippets; when you've tried 'em, it's hard to do without 'em. I mean, keystrokes, who needs 'em, right?
#+BEGIN_SRC emacs-lisp
(yas-global-mode 1)
#+END_SRC
** Miscellanous
*** Whitespace                                             :minor:builtin:
#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-line-column 80) ;; limit line length
(setq whitespace-style '(face trailing tabs lines-tail))
(setq whitespace-global-modes '(not org-mode web-mode "Web"))
(global-whitespace-mode)
#+END_SRC
*** Searching
**** Anzu (about search results)                          :external:minor:
#+BEGIN_SRC emacs-lisp
(global-anzu-mode t)
(global-set-key (kbd "M-%") 'anzu-query-replace)
(global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp)
#+END_SRC
**** Wgrep-ag
Sometimes after you've found a bunch of things, you want to edit.. Kind of a find-and-replace sort of deal, maybe?
#+BEGIN_SRC emacs-lisp
(autoload 'wgrep-agp-setup "wgrep-ag")
(add-hook 'ag-mode-hook 'wgrep-ag-setup)
#+END_SRC
*** Interface customization
**** Smart mode line
#+BEGIN_SRC emacs-lisp
(setq sml/theme 'dark)
(sml/setup)
#+END_SRC
**** Default text scale
This handy little package increases the size of the font in the whole frame.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-=") 'default-text-scale-increase)
(global-set-key (kbd "C-x C--") 'default-text-scale-decrease)
#+END_SRC
*** Auto completion
#+BEGIN_SRC emacs-lisp
(eval-after-load 'auto-complete
  '(add-to-list 'ac-modes 'inf-ruby-mode))
(add-hook 'inf-ruby-mode-hook 'ac-inf-ruby-enable)

(eval-after-load 'inf-ruby
  '(define-key inf-ruby-mode-map (kbd "TAB") 'auto-complete))

(define-key ac-complete-mode-map (kbd "C-:") 'ac-complete-with-helm)

(require 'auto-complete-config)
(ac-config-default)
#+END_SRC emacs-lisp
*** Mew (email)
Mew's config is in ~/.mew.el so you won't see it here. Nee-ner nee-ner nee-----ner.
#+BEGIN_SRC emacs-lisp
(autoload 'mew "mew" nil t)
(autoload 'mew-send "mew" nil t)

;; Optional setup (Read Mail menu):
(setq read-mail-command 'mew)

;; Optional setup (e.g. C-xm for sending a message):
(autoload 'mew-user-agent-compose "mew" nil t)
(if (boundp 'mail-user-agent)
    (setq mail-user-agent 'mew-user-agent))
(if (fboundp 'define-mail-user-agent)
    (define-mail-user-agent
      'mew-user-agent
      'mew-user-agent-compose
      'mew-draft-send-message
      'mew-draft-kill
      'mew-send-hook))

(setq mew-use-master-passwd t)
#+END_SRC
*** Calendar, dates, times
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1) ;; Monday
#+END_SRC
**** Diary
#+BEGIN_SRC emacs-lisp
(setq diary-file "~/Google Drive/diary")

(setq view-diary-entries-initially t
      mark-diary-entries-in-calendar t
      number-of-diary-entries 7)
(add-hook 'diary-display-hook 'diary-fancy-display)
(add-hook 'today-visible-calendar-hook 'calendar-mark-today)
#+END_SRC
**** calfw, the calendar framework
#+BEGIN_SRC emacs-lisp
(require 'calfw)
(require 'calfw-cal)
(require 'calfw-ical)
(require 'calfw-org)

(setq cfw:fchar-junction ?╋
      cfw:fchar-vertical-line ?┃
      cfw:fchar-horizontal-line ?━
      cfw:fchar-left-junction ?┣
      cfw:fchar-right-junction ?┫
      cfw:fchar-top-junction ?┯
      cfw:fchar-top-left-corner ?┏
      cfw:fchar-top-right-corner ?┓)
#+END_SRC

Here is a sample function where you could, for instance, put your Google Calendar information (mostly so I remember how to create the secret file on a new computer).

#+BEGIN_QUOTE
(defun stag-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Green")
    (cfw:cal-create-source "Orange")
    (cfw:ical-create-source "gcal" "gcal-ics-link" "Blue")
    )))
#+END_QUOTE
*** File system browsing (dired)
dired-jump is awesome (C-x C-j in any buffer)
#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (setq-default dired-listing-switches "-alhv")
;; Changed my mind. I prefer seeing just the files:
(add-hook 'dired-mode-hook 'dired-hide-details-mode)

;; Auto-refresh silently
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

This will make org-mode behave kinda like a two-pane file manager: with two direds open, you can copy/rename and the default target will be the other pane.
Using split-window-vertically from the first dired might be required to make this work.
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

It's also nice to have dired with M-< and M-> take you to first and last file
#+BEGIN_SRC emacs-lisp
(require 'dired)
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (next-line 2))

(define-key dired-mode-map
  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (next-line -1))

(define-key dired-mode-map
  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
#+END_SRC

** Playing
*** Playing MUDs
#+BEGIN_SRC emacs-lisp
(autoload 'mu-open "mu" "Play on MUSHes and MUDs" t)
(add-hook 'mu-connection-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC
